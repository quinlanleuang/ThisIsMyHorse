数据库锁，是当出现并发访问的时候，数据库为了合理地控制资源的访问规则而设计的一种数据结构

### 锁分类（根据加锁范围）

- 全局锁 - 对整个数据库实例加锁
- 表锁 - 对整个表加锁
- 行锁 - 对表中一行加锁

### 全局锁

- 加全局读锁方法 - use某个db之后，执行flush tables with read lock

- 影响 - 不允许增删改数据，建改表和更新类事务的提交

- 使用场景 - 全库逻辑备份

- 备份为什么需要设置库只读，如果不加锁，备份系统备份得到的库不是一个逻辑时间点。例子：备份余额表，用户买课，备份用户课程表，造成数据不一致

- mysqldump使用--single-transaction参数会在导数据之前启动一个事务，确保拿到一致性视图（一致性读）

- single-transaction方法只适用于所有的表使用事务引擎的库，如果有一个表使用不支持事务的引擎，那么备份只能通过FTWRL方法

- set global readonly=true VS FTWRL，建议使用FTWRL

  ```
  1. 有些系统readonly被用来做其他逻辑，比如判断一个库是主库还是备库
  2. 异常处理机制有差别。当客户端异常断开时，FTWRL能够自动释放全局锁，而readonly会导致整个库长时间不可写
  ```

### 表级锁

- 表锁语法  lock tables ... read/write。通过unlock tables主动释放锁，也可以在客户端断开的时候自动释放。

- lock tables除了会限制其他进程的读写外，也会限制本线程的操作

- 另一类表级锁是原数据锁MDL（Meta Data Lock），MDL不需要显示地使用，在访问一个表的时候会自动加上。

- MySQL5.5引入的MDL，做DDL时加写锁，做DML时加读锁。读锁之间不互斥，读写锁之间和写锁之间是互斥的。

- 事务中MDL锁，在语句执行时开始申请，但是语句结束后并不会马上释放，而是会等到事务提交后才释放

- 如何安全地给小表加字段

  ```
  1. 解决长事务。通过information_schema的innodb_trx查看，如果在执行DDL操作时，有长事务，可以考虑暂停DDL或者kill掉长事务
  2. 如果变更的是一个热点表（请求频繁），这时kill掉可能不管用，因为新的请求马上就来了，可以在alter语句里设置等待时长，保证在指定时间内拿不到MDL写锁也不会阻塞后续操作。
  3. MariaDB和AliSQL支持DDL NOWAIT/WAIT N语法
  ALTER TABLE T NOWAIT ADD COLUMN...
  ALTER TABLE T WAIT N ADD COLUMN...
  ```

  