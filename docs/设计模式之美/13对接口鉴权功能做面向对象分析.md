### 第一轮基础分析
- 给每一个服务调用方分配一个AppID和secret，调用方在接口请求时都带上这两个参数，在服务端解析出请求中的AppID和secret并与存储在服务端的AppID和secret做对比，如果一致则认证成功，否则认证失败
  
### 第二轮分析优化
- 由于密码（secret）明文传输，很容易被截获到，很不安全
- 同样的，如果将密码加密之后传输，黑客可以截获密码密文和AppID，在通过重放攻击接口
- 我们可以借助OAuth的验证思路来解决
- 调用方将请求URL、AppID和密码拼接在一起后进行加密，生成一个token，然后调用方将这个token和AppID随URL传递给服务端
- 服务端从请求中解析出AppID和token，根据AppID取出对应的密码（secret），根据相同的算法计算得出一个s_token。然后比较token和s_token，如果完全一致则认证成功，否则认证失败

![](https://static001.geekbang.org/resource/image/07/d7/0704c4806f9d6c01bb20884d05ee54d7.jpg)

### 第三轮分析优化
- 由于每个URL拼接上AppID、密码生成的token都是固定的。黑客截获URL、AppID和token之后，依然可以进行重放攻击
- 为了解决这个问题，我们可以优化token的生成算法，引入一个随机变量。让每次生成的token都不一样
- 可以选择时间戳作为随机变量，token是根据URL、AppID、secret和时间戳四者进行加密生成的
- 调用方发送请求时带上URL、AppID、时间戳和token
- 服务端接收到请求之后，首先验证当前时间戳和解析得到的时间戳是否在一定的时间窗口内，如果不在，则token失效，认证失败
- 如果token未失效，服务端通过相同的算法生成s_token，然后比较token和s_token的值，如果完全一致则认证成功，否则认证失败

![](https://static001.geekbang.org/resource/image/bd/60/bde932c73c6636ad85380e4801dbfb60.jpg)

### 第四轮优化分析
- 攻防之间，本没有绝对的安全，我们能做的就是提高攻击的成本
- 这个方案是权衡了安全性、开发成本、接口性能的折中
- 关于AppID和密码的存储，最好能灵活地支持各种不同的存储方式。我们不一定针对每一种存储方式都去实现一遍，但要留有拓展点。保证系统的扩展性和灵活性